listener('resize', resize);
listener('keydown', e => {
 if (e.key == 'm')
 modeToggle();
 
 if (e.key = 'c')
 session.cars = prompt('How many cars for this run?', '5');
 
 if (e.key = 't')
 session.traffic = prompt('How much traffic for this run?', '100');
 
 if (e.key == ' ')
 if (Game.gameFrame == 0) Game.start({ ls: false });
 else Game.stop();
})

const { Game } import `Sprout`;
const { Road, Car } import `lib`;
const mode = Number(session.mode) || 0;

const netBoard = Q('#netBoard');
netBoard.width = 300;

const context = netBoard.getContext('2d');
Game.initialize(60, model => {
 with(model) {
  if (mode == 0) for (let vehicle of traffic)
  vehicle.update(road.borders, []);
  
  for (let car of cars)
  car.update(road.borders, traffic.filter(c => c != car));
  getData(this).then(result => (data = result));
  
  best = rln.sort();
  bestCar = cars.find(car => car.brain == best);
  draw(ctx);
  
  if (gameFrame % 15 == 0)
  logData();
  
  context.lineDashOffset = -gameFrame /30;
  Visualizer.drawNetwork(context, best);
 }
});

const rln = new RLN([5, 6, 6, 4], 0);
Game.board.height = innerHeight;
session.cars = session.cars ?? 5;
session.traffic = session.traffic ?? 100;

const road = new Road(Game.board.width /2, Game.board.width *.9);
const cars = mode == 0 ? generateCars(session.cars) : generateTraffic(session.cars, 'AI');
const traffic = mode == 0 ? generateTraffic(session.traffic) : cars;
cars.push(new Car({
 x: road.getLaneCenter(0),
 y: Game.board.height /2,
 width: 30, height: 50,
 maxSpeed: 8,
 controlType: 'KEYS',
}));

let best = cars[0].brain;
let bestCar = cars[0];
let data = await getData(Game);

const file = cache['best'];
if (file != '')
{
 best = RLN.parseBest(file);
 rln.setData(best, .06);
 
 for (let i = 0; i < cars.length; i ++)
 cars[i].brain = rln.nets[i];
}

function generateTraffic(n, controlType = 'DUMMY') {
 const traffic = [];
 for (let i = 1; i <= Number(n); i ++)
 {
  const car = new Car({
   x: road.getLaneCenter(math.ran(0, road.laneCount)),
   y: i == 1 && mode == 1 ? Game.board.height /2 : math.ran(-Game.board.height /3, -6500),
   width: 30, height: 50,
   maxSpeed: math.ran(1, 3),
   controlType,
  })
  
  if (controlType == 'AI') rln.push(car.brain);
  traffic.push(car);
 }
 
 return traffic;
}

function generateCars(n) {
 const cars = []
 for (let i = 1; i <= Number(n); i ++)
 {
  const car = new Car({
   x: road.getLaneCenter(1),
   y: Game.board.height /2,
   width: 30, height: 50,
   controlType: 'AI',
   maxSpeed: 5.5,
  });
  
  rln.push(car.brain);
  cars.push(car);
 }
 
 return cars;
}

function save() {
 cache['best.txt'] = RLN.stringifyBest(rln);
 if (data.newhighscore) cache['high-score'] = best.score;
}

function discard() {
 cache['best'] = '';
 cache['high-score'] = '0';
}

function draw(ctx) {
 ctx.save();
 ctx.translate(0, -bestCar.y +Game.board.height *.5);

 road.draw(ctx);
 if (mode == 0) for (let vehicle of traffic)
 vehicle.draw(ctx, 'red');
 
 ctx.globalAlpha = .2;
 for (let car of cars.filter(car => car != bestCar))
 car.draw(ctx, 'blue');
 
 ctx.globalAlpha = 1;
 for (let car of cars.filter(car => car.useBrain == false))
 car.draw(ctx, 'darkblue', true);
 
 bestCar.draw(ctx, 'blue', true);
 ctx.restore();
}

function logData() {
 terminal.clear();
 const arr = [
  'Cars Alive: ' +data.carsAlive,
  'Score: ' +best.score +(data.newhighscore ? '^' : ''),
  'Highscore: ' +data.highscore,
 ];
 
 log(arr.join('\n'));
}

function getData(model) {
 return new Promise(async resolve => {
  const carsAlive = cars.filter(car => !car.damaged).length;
  const highscore = cache['high-score'];
  
  resolve({
   carsAlive,
   newhighscore: best.score > Number(highscore),
   highscore,
  });
 })
}

resize();
Game.start({ ls: false });
win(Game, save, discard, modeToggle);

function resize() {
 Game.board.height = window.innerHeight;
 netBoard.height = window.innerHeight;
}

function modeToggle(i) {
 const n = Number(session.mode) || 0;
 session.mode = i ?? (n != 1 ? n +1 : 0);
}